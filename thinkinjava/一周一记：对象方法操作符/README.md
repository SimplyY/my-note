对象 方法 操作符
===
**极容易出错**的地方
----

- =，== 操作对象的时候都是**对引用进行使用和比较**

- 判断String类型的字符串是否相等 **用 equals（）**，==只是对引用进行比较！


- foreach仅仅是在这样做

	> (某种数据类型)int element = array[i] 

	所以，对element赋值 ，不会改变array[i]，然而对**对象反之**，因为对象的=是将引用给element，这样一来element的改变必然会改变array[i]。


- 数组都是对象，比如
	> int a[] = {1,2};
	> b = a;
	
	此时当且仅有一个数组在堆空间里，也就是说，无论是对a，还是b其中的一个做了改变，他们会同时改变

对象导论
---
- 对万物**分类**的意义：
> 我们之所以将自然界分解，组织成各种概念，并按其含义分类、起名字，主要是因为我们是整个口语交流社会共同的协定的参与者，这个协定以语言的形式固定下来.....除非赞同这个协定，否则我们根本无法交谈。

- 解决问题的复杂性（一般和难度成正比）直接取决于抽象的类型和质量（**程度**）。

- （初学很容易弄混淆）在程序中你所可以使用的变量名实际上只是**对象的引用**（并不是对象）

- （初学很容易弄混淆）对象存放在堆（**没有任何引用指向的对象**，在某些时候会由垃圾回收器清理），变量在堆栈（离开作用域，就会被清理）

方法 操作符
----
- 方法名 + 参数列表 = 签名（不含返回值）

- 如果传入参数的类型名是所需类型的子类，则会自动向上转型；如果传入是基本类型，窄化（数据量变小了，比如精度变低）是不准许的。

- 指数表示：e10和E10表示的是10的十次方。

- 当需要用来判断对象的所有属性是否相等时，**equal需要重写**(除了String可以直接用)，不然就和==(判断地址是否相等)效果一样（因为所有类都继承于Object，而其的equal方法就是用==来判断，而String重写了）

- arraylist(所有容器collection只能储存对象，int等不能储存)，get返回对象，indexof返回index





